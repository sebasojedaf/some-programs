# -*- coding: utf-8 -*-
"""trabajo econo2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FhzzD7LcoM72wZzgr1Nv-0KtssoOAQdE
"""

import pandas as pd
from matplotlib.colors import LogNorm
from scipy.optimize import curve_fit
import numpy as np
import random
import matplotlib.pyplot as plt
from google.colab import files

def code():
  M=1000
  N=1000
  simu=1000
  steps=10000
  IPROMEDIO=M/N
  vect=[IPROMEDIO]*1001
  aux=[0.0]*1001
  for ii in range(simu):
      vect.sort()
      if ii>0:
        for zz in  range(len(vect)):
            aux[zz]=aux[zz]+vect[zz]
            vect[zz]=IPROMEDIO
      for kk in range(steps):
          i = random.randint(0, 1000)
          j = random.randint(0, 1000)
          if i == j:
              i = random.randint(0, 1000)
              j = random.randint(0, 1000)
          delta=random.random()*IPROMEDIO #*(vect[i]+vect[j])*0.5
          if vect[j]-delta>0:
              vect[i]=vect[i]+delta;
              vect[j]=vect[j]-delta;

  aux.sort()
  for x in range(len(vect)):
      aux[x]=aux[x]/simu
  n, bins, patches=plt.hist(aux,bins=100)#,density=True)
  #plt.title("Densidad de probabilidad")
  plt.title("Distribución de dinero", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  #plt.ylabel("Probabilidad", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.show()
  fraccion=[0.0]*1001
  fraccionacum=[0.0]*1001
  aux3=[0.001]*1001
  entro=0
  for x in range(len(bins)-1):
    if n[x]==0:
      n[x]=1000
    entro=entro-(n[x]/1001)*np.log(n[x]/1001)
  qq=0
  suma=0.0
  for  kk in range(len(vect)):
      fraccion[kk]=aux[kk]/1000
      if(kk==0):
        fraccionacum[kk]= fraccion[kk]

      aux3[kk]=(kk+1)*0.001
      while(qq<kk):
        fraccionacum[kk]=fraccionacum[kk]+fraccion[qq]
        qq=qq+1
      qq=0
  for kk in range(len(vect)-1):
    suma=(fraccionacum[kk]+fraccionacum[kk+1])*(aux3[kk+1]-aux3[kk])+suma

  gini=1-suma;
  #  //calculo gini////////////////////////////////////////////////
#//calculo theil//////////////////////////////////////////////////
  suma2=0.0
  for kk in range(len(vect)):
    suma2=(aux[kk])*(np.log(aux[kk]))+ suma2

  theil=suma2/1000
  theilnormalizado=theil/np.log(1000)
  print( gini , theil, theilnormalizado,entro)
   #///////////////////////////////////////////////////////////////////

  file=open("datos.txt","w")
  for i in (bins):
    file.write(str(i))
    file.write("\n")
  file.close()
  files.download("datos.txt")
  file=open("datosy.txt","w")
  for i in (n):
    file.write(str(i))
    file.write("\n")
  file.close()
  files.download("datosy.txt")
  bins=np.delete(bins,100)
  def fun(x,b):
    return b*np.exp(-x/b)
  res, cov=curve_fit(fun,bins, n)
  print(res)
if __name__ == "__main__":
    code()

import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
import matplotlib.pyplot as plt
from google.colab import files
def code():
  M=1000
  N=1000
  simu=5000
  steps=100000
  IPROMEDIO=M/N
  #delta=0.4
  lamb=0.7
  vect=[IPROMEDIO]*1001
  aux=[0.0]*1001
  for ii in range(simu):
      vect.sort()
      if ii>0:
        for zz in  range(len(vect)):
            aux[zz]=aux[zz]+vect[zz]
            vect[zz]=IPROMEDIO
      for kk in range(steps):
          i = random.randint(0, 1000)
          j = random.randint(0, 1000)
          if i == j:
              i = random.randint(0, 1000)
              j = random.randint(0, 1000)
          delta=abs((1.0-lamb)*(random.random()*vect[i]-(1-random.random())*vect[j]))
          if vect[j]-delta>0:
              vect[i]=vect[i]+delta
              vect[j]=vect[j]-delta

  aux.sort()
  for x in range(len(vect)):
      aux[x]=aux[x]/simu
  n, bins, patches=plt.hist(aux,bins=100)#,density=True)
  #plt.title("Densidad de probabilidad")
  plt.title("Distribución de dinero ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  #plt.ylabel("Probabilidad", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.show()
  entro=0
  for x in range(len(bins)-1):
    if n[x]==0:
      n[x]=1000
    entro=entro-(n[x]/1001)*np.log(n[x]/1001)

  fraccion=[0.0]*1001
  fraccionacum=[0.0]*1001
  aux3=[0.001]*1001
  qq=0
  suma=0.0
  for  kk in range(len(vect)):
      fraccion[kk]=aux[kk]/1000
      if(kk==0):
        fraccionacum[kk]= fraccion[kk]

      aux3[kk]=(kk+1)*0.001
      while(qq<kk):
        fraccionacum[kk]=fraccionacum[kk]+fraccion[qq]
        qq=qq+1
      qq=0
  for kk in range(len(vect)-1):
    suma=(fraccionacum[kk]+fraccionacum[kk+1])*(aux3[kk+1]-aux3[kk])+suma

  gini=1-suma;
  #  //////////////////////////////////////////////////////////////
  #//calculo theil//////////////////////////////////////////////////
  suma2=0.0
  S=0
  for kk in range(len(vect)):
    suma2=(aux[kk])*(np.log(aux[kk]))+ suma2
    S=S+(aux[kk]/1000)*(np.log(1000/aux[kk]))
  #///////////////////////////////////////////////////////////////////
  theil=suma2/1000
  theilnormalizado=theil/np.log(1000)
  print( gini , theil, theilnormalizado,S,entro)

   #///////////////////////////////////////////////////////////////////

  file=open("datos.txt","w")
  for i in (bins):
    file.write(str(i))
    file.write("\n")
  file.close()
  files.download("datos.txt")
  file=open("datosy.txt","w")
  for i in (n):
    file.write(str(i))
    file.write("\n")
  file.close()
  files.download("datosy.txt")
if __name__ == "__main__":
    code()

import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
import matplotlib.pyplot as plt
from google.colab import files
def code():
  M=1000
  N=1000
  simu=1000
  steps=10000
  IPROMEDIO=M/N
  vect=[IPROMEDIO]*1001
  aux=[0.0]*1001
  J=3.0
  for ii in range(simu):
      vect.sort()
      if ii>0:
        for zz in  range(len(vect)):
            aux[zz]=aux[zz]+vect[zz]
            vect[zz]=IPROMEDIO

      IPROMEDIO=M/N
      for kk in range(steps):
          i = random.randint(0, 1000)
          nu=np.random.normal(1.0,0.5)
          delta=(nu-1.25)*(vect[i]/IPROMEDIO)+J*(1-vect[i]/IPROMEDIO)
          if vect[i]+delta>0:
              vect[i]=vect[i]+delta
              IPROMEDIO=IPROMEDIO+delta/1000
  aux.sort()
  sump=0
  for x in range(len(vect)):
      aux[x]=aux[x]/simu
      sump=aux[x]+sump
  iprom=sump/len(vect)-1
  n, bins, patches=plt.hist(aux,bins=100)#,density=True)
  #plt.title("Densidad de probabilidad")
  plt.title("Distribución de dinero ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  #plt.ylabel("Probabilidad", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.show()
  fraccion=[0.0]*1001
  fraccionacum=[0.0]*1001
  aux3=[0.001]*1001
  entro=0
  for x in range(len(bins)-1):
    if n[x]==0:
      n[x]=1000
    entro=entro-(n[x]/1001)*np.log(n[x]/1001)
  qq=0
  suma=0.0
  for  kk in range(len(vect)):
      fraccion[kk]=aux[kk]/iprom
      if(kk==0):
        fraccionacum[kk]= fraccion[kk]

      aux3[kk]=(kk+1)*0.001
      while(qq<kk):
        fraccionacum[kk]=fraccionacum[kk]+fraccion[qq]
        qq=qq+1
      qq=0
  for kk in range(len(vect)-1):
    suma=(fraccionacum[kk]+fraccionacum[kk+1])*(aux3[kk+1]-aux3[kk])+suma
  gini=1-suma;
  #  //////////////////////////////////////////////////////////////
  #//calculo theil//////////////////////////////////////////////////
  suma2=0.0
  for kk in range(len(vect)):
    suma2=(aux[kk])*(np.log(aux[kk]))+ suma2
  theil=suma2/1000
  theilnormalizado=theil/np.log(1000)
  print( gini , theil, theilnormalizado,entro)


   #///////////////////////////////////////////////////////////////////

  file=open("datos.txt","w")
  for i in (bins):
    file.write(str(i))
    file.write("\n")
  file.close()
  #files.download("datos.txt")
  file=open("datosy.txt","w")
  for i in (n):
    file.write(str(i))
    file.write("\n")
  file.close()
  #files.download("datosy.txt")
if __name__ == "__main__":
    code()

from google.colab import files
uploaded = files.upload()

from numpy.core.fromnumeric import size
import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from google.colab import files
from sympy.abc import z,a,b
uploaded = files.upload()
def funn(x,a,b):
    return a*(x**b)
def code():
  x=np.linspace(0.0078,0.14)
  y=funn(x,0.00470644, -2.18125483 )
  datos2 = []
  with open("data0petroleo.txt") as fname:#"data0ecopetrol.txt"        "data0petroleo.txt"   "data0dolar.txt"
	  for lineas in fname:
		  datos2.extend(lineas.split())

  for i in range(len(datos2)):
    datos2[i]=float(datos2[i])
  print (x,datos2)
  plt.plot(x,y, ":",color="b")
  n, bins, patches=plt.hist(datos2,bins=100)
  plt.title("Distribución de log-ret Barrilpetróleo", size = 16)
  plt.xlabel("log-retornos", size = 16)
  plt.ylabel("frecuencia ", size = 16)
  plt.show()
  n=np.append(n,0)
  res, cov=curve_fit(funn,bins, n)
  print(res,cov)

if __name__ == "__main__":
    code()

from numpy.core.fromnumeric import size
import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from google.colab import files
from sympy.abc import z,a,b
#uploaded = files.upload()
def code():
  x=np.linspace(0.0078,0.14)
  y=funn(x,0.00470644, -2.18125483 )
  datos2 = []
  with open("dataeco.txt") as fname:#
	  for lineas in fname:
		  datos2.extend(lineas.split())
  for i in range(len(datos2)):
    datos2[i]=float(datos2[i])

  print (len(datos2))

  prom1eco=np.mean(datos2[0:1099])/1099
  prom2eco=np.mean(datos2[1099:2198])/1099
  prom3eco=np.mean(datos2[2198:3297])/1099
  for i in range(len(datos2)):
    if i <1099:
      datos2[i]=datos2[i]-prom1eco
    if 1099 < i <2198:
      datos2[i]=datos2[i]-prom2eco
    if 2198 < i <3297:
      datos2[i]=datos2[i]-prom3eco

  rango1eco=max(datos2[0:1099])-min(datos2[0:1099])
  rango2eco=max(datos2[1099:2198])-min(datos2[1099:2198])
  rango3eco=max(datos2[2198:3297])-min(datos2[2198:3297])
  std1eco=np.std(datos2[0:1099])
  std2eco=np.std(datos2[1099:2198])
  std3eco=np.std(datos2[2198:3297])
  R1ECO=rango1eco/std1eco
  R2ECO=rango2eco/std2eco
  R3ECO=rango3eco/std3eco
  RSeco=(R1ECO+R2ECO+R3ECO)/3

  #datoss=[]
  datos = []
  for i in range(3001):
    a=np.random.normal(loc=0.0, scale=1.0)
    while 1.0<a or a<-1.0:
      a=np.random.normal(loc=0.0, scale=1.0)
    datos.append(a)
  Datos=datos
  prom1=np.mean(datos[0:1000])
  prom2=np.mean(datos[1000:2000])
  prom3=np.mean(datos[2000:3000])
  for i in range(3000):
    if i <1000:
      datos[i]=datos[i]-prom1
    if 1000 < i <2000:
      datos[i]=datos[i]-prom2
    if 2000 < i <3000:
      datos[i]=datos[i]-prom3
  rango1=max(datos[0:1000])-min(datos[0:1000])
  rango2=max(datos[1000:2000])-min(datos[1000:2000])
  rango3=max(datos[2000:3000])-min(datos[2000:3000])
  std1=np.std(datos[0:1000])
  std2=np.std(datos[1000:2000])
  std3=np.std(datos[2000:3000])
  R1=rango1/std1
  R2=rango2/std2
  R3=rango3/std3
  RS=(R1+R2+R3)/3.0
  p1=np.log(RS)
  m=6
  promedio=[]
  for i in range(m):
    promedio.append(np.mean(Datos[int(i*len(Datos)/m):int((i+1)*len(Datos)/m)]))

  for i in range(3000):
    if i <len(Datos)/m:
      Datos[i]=Datos[i]-promedio[0]
    elif len(Datos)/m < i <2*len(Datos)/m:
      Datos[i]=Datos[i]-promedio[1]
    elif 2*len(Datos)/m < i <3*len(Datos)/m:
      Datos[i]=Datos[i]-promedio[2]
    elif 3*len(Datos)/m < i <4*len(Datos)/m:
      Datos[i]=Datos[i]-promedio[3]
    elif 4*len(Datos)/m < i <5*len(Datos)/m:
      Datos[i]=Datos[i]-promedio[4]
    elif 5*len(Datos)/m < i <6*len(Datos)/m:
      Datos[i]=Datos[i]-promedio[5]
  rango=[]
  r=[]
  for i in range(m):
    #if i !=0:
    rango.append(max(datos[int(i*len(Datos)/m):int((i+1)*len(Datos)/m)])-min(datos[int(i*len(Datos)/m):int((i+1)*len(Datos)/m)]))
    #if i ==0:
     #  rango.append(max(datos[0:int(len(Datos)/m)])-min(datos[0:int(len(Datos)/m)]))
    r.append(rango[i]/np.std(Datos[int(i*len(Datos)/m):int((i+1)*len(Datos)/m)]))

  RS2=np.mean(r)#(sum(r))/m
  p2=np.log(RS2)
  x=[1000,500]
  xx=np.log(x)
  y=[p1,p2]
  print(xx,y)
  plt.plot(xx, y, "r")
  plt.grid(True)
  plt.xlabel("ln(M)", size = 14)
  plt.ylabel("ln(R/S)", size = 14)
  plt.show()
  #print(prom1,prom2,prom3)
if __name__ == "__main__":
    code()





from numpy.core.fromnumeric import size
import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from google.colab import files

x = (6.5 , 9.3 , 14.6)
y = (3.2, 9.7, 11.3)
y_error = (1.2 , 2.1, 3.6)
plt.errorbar(x, y, yerr=y_error, ecolor="black", fmt="o")
z = np.array(range(6,16))
v = -2 + 1 * (z)
plt.grid(True)
plt.plot(z,v)
plt.xlabel('tiempo (s)', size= 11 )
plt.ylabel('Desplazamiento x(cm)', size= 11 )
plt.title('Ajuste caso C', size= 15)
plt.savefig("\chi2.jpg")
plt.show()

x = (6.5 , 9.3 , 14.6)
y = (3.2, 9.7, 11.3)
y_error = (1.2 , 2.1, 3.6)
plt.errorbar(x, y, yerr=y_error, ecolor="black", fmt="o")


z = np.array(range(6,16))
v = -11.9 + 2.32 * (z)
plt.grid(True, which='major', axis='both')
plt.plot(z,v)

plt.xlabel('tiempo (s)', size= 11 )
plt.ylabel('Desplazamiento x(cm)', size= 11 )
plt.title('Ajuste Caso A', size= 15)
plt.savefig("Caso A.jpg")
plt.show()

x = (6.5 , 9.3 , 14.6)
y = (3.2, 9.7, 11.3)
y_error = (1.2 , 2.1, 3.6)
plt.errorbar(x, y, yerr=y_error, ecolor="black", fmt="o")

z = np.array(range(6,16))
v = -3.3 + 1 * (z)
plt.grid(True, which='major', axis='both')
plt.plot(z,v)
plt.xlabel('tiempo (s)', size= 11 )
plt.ylabel('Desplazamiento x(cm)', size= 11 )
plt.title('Ajuste Caso B', size= 15)
plt.savefig("Caso B.jpg")
plt.show()

x = (6.5 , 9.3 , 14.6)
y = (3.2, 9.7, 11.3)
y_error = (1.2 , 2.1, 3.6)
plt.errorbar(x, y, yerr=y_error, ecolor="black", fmt="o")

z = np.array(range(6,16))
v = -4.13 + 1.13 * (z)
plt.grid(True, which='major', axis='both')
plt.plot(z,v)
plt.xlabel('tiempo (s)', size= 11 )
plt.ylabel('Desplazamiento x(cm)', size= 11 )
plt.title('Caso C', size= 15)
plt.savefig("Caso C.jpg")
plt.show()


x = (6.5 , 9.3 , 14.6)
y = (3.2, 9.7, 11.3)
y_error = (1.2 , 2.1, 30)
plt.errorbar(x, y, yerr=y_error, ecolor="black", fmt="o")

z = np.array(range(6,16))
v = -11.49 + 2.26 * (z)
plt.grid(True, which='major', axis='both')
plt.plot(z,v)
plt.xlabel('tiempo (s)', size= 11 )
plt.ylabel('Desplazamiento x(cm)', size= 11 )
plt.title('Caso D', size= 15)
plt.savefig("Caso D.jpg")
plt.show()

from numpy.core.fromnumeric import size
import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from google.colab import files
def code():

  y=[]
  x=np.linspace(0,5.0,150 )
  for i in range(len(x)):
    y.append(1+1*np.cos(2*np.pi*x[i]))
  plt.plot(x, y, "g^")
  #plt.legend(loc='upper right')
  plt.grid(True)
  plt.xlabel("2Δz/λ", size = 14)
  plt.ylabel("I / I$_{0}$", size = 14)
  plt.yticks(range(0,3,1))
  plt.show()


if __name__ == "__main__":
    code()

from google.colab import files
uploaded = files.upload()

from numpy.core.fromnumeric import size
import pandas as pd
from matplotlib.colors import LogNorm
import numpy as np
import random
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from google.colab import files
from sympy import integrate, init_printing
from sympy.abc import z,a,b
def code():
  x=[]
  y=[]
  xx=np.linspace(0,190,150 )
  yy=[]

  datos2 = []
  with open("gauss+recta+incert.csv") as fname:
	  for lineas in fname:
		  datos2.extend(lineas.split())

  for i in range(0,len(datos2),2):
    x.append(float(datos2[i]))
    if i!=0:
      y.append(float(datos2[i-1]))
  for i in range(len(xx)):
    yy.append(5200*np.exp(-xx[i]/41))
  print (x)
  y.append(0.7)
  print (y)
  #print (len(x),len(y))
  #plt.plot(x,y, ":",color="b")marker = "."

 #plt.semilogy(xx, yy, ".", color = "yellow",label="datos")
  plt.plot(xx, yy, "-", color = "red", label="Ajuste exponencial")
  plt.legend(loc='upper right')
  plt.plot(x, y, "g^",color = "black",label="datos experimentales")
  plt.legend(loc='upper right')
  y_erorr=np.sqrt(y)
  #print(y_erorr)y_erorr.sort()print(y_erorr)
  #plt.errorbar(x,y,yerr=y_erorr)
  plt.errorbar(x,y,yerr=y_erorr, ecolor="black",fmt=".")
  plt.grid(True)
  plt.title("Decaimiento nuclear del 137Cs ", size = 15)
  plt.xlabel("tiempo(años)", size = 11)
  plt.ylabel("Decaimientos por año", size = 11)
  plt.show()





import pandas as pd
from matplotlib.colors import LogNorm
from scipy.optimize import curve_fit
import numpy as np
import random
import matplotlib.pyplot as plt
from google.colab import files

def code():
  recurso=1.0
  sciencia=1.0
  simu=10
  steps=100
  energy=5000.0
  aux=[]
  aux2=[]
  #auxriqueza=[]
  T=1/2
  #0.ahorro  1.tipor  2.production  3workincome  4 investincome 5income  6 empleados 7consumo  8ganainvest  9payinvest  10salario 11wealth 12class
  v=[energy, 0, 0.0,0.0,0.0, 0.0, [],0.0, 0.0,0.0,0.0, 5000.0, 1]
  riqueza=[v]*51
  productividad=[0.0]*51
  e=[2500,4500, 100000, 400000]
  for ll in range(len(productividad)):
      productividad[ll]=np.random.normal(loc=20000.0, scale=20000.0)
      while  productividad[ll]< 0.0:
        productividad[ll]=np.random.normal(loc=10000.0, scale=20000.0)
      riqueza[ll][2]=productividad[ll]*sciencia*recurso#production
  print(len(riqueza))
  for t in range(steps):
    for zz in range(len(productividad)):
      riqueza[zz][2]=productividad[zz]*sciencia*recurso#production
      if riqueza[zz][1]==0:
        riqueza[zz][3]=riqueza[zz][2]#workincomeeeee
      elif riqueza[zz][1]==1:
        riqueza[zz][3]=riqueza[zz][10]#pago de salario
      if  len(riqueza[zz][6])!=0:  #riqueza[zz][1]==0.0 and
        for kk in riqueza[zz][6]:
          riqueza[zz][4]=riqueza[kk][2]-riqueza[kk][10]+riqueza[zz][4]#investincome
      riqueza[zz][5]=riqueza[zz][4]+riqueza[zz][3]#INCOME TOTAl
      riqueza[zz][11]=riqueza[zz][5]+riqueza[zz][0]*T #wealth
      #print(riqueza[zz][11],riqueza[zz][12],t, zz)
      #class diferentiation###################
      if e[0]>=riqueza[zz][11]:
        riqueza[zz][12]=1
      if t>0 and riqueza[zz][11]>=e[0] and e[1]>=riqueza[zz][11]:
        riqueza[zz][12]=2
      elif riqueza[zz][11]>=e[1] and e[2]>=riqueza[zz][11]:
          riqueza[zz][12]=3
      elif riqueza[zz][11]>=e[2]:
          riqueza[zz][12]=4
      if riqueza[zz][12]==1:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 500.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0],riqueza[zz][11]/4)
      elif riqueza[zz][12]==2:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 1500.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/4)
      elif riqueza[zz][12]==3:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 40000.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/4)
      if riqueza[zz][12]==4:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 100000.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/4)
      riqueza[zz][11]=riqueza[zz][11]-riqueza[zz][7]+riqueza[zz][5]
      print(riqueza[zz][11],riqueza[zz][12],t, zz)
      if riqueza[zz][11]<=e[riqueza[zz][12]-1]:
        print("holaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        if riqueza[zz][12]<3:
          print("hola2")
          print(riqueza[zz][12])
          for r in range(51):
            print("putamadreeeeeeee",r,riqueza[r][12],riqueza[r][11])
            if riqueza[r][12]>2 :
              print("holaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa3")
              riqueza[zz][1]=1
              productividad[zz]=(productividad[zz]+productividad[r])*0.5
              riqueza[r][6].append(zz)
              riqueza[zz][10]=e[0]#salario
             # riqueza[i][11]=riqueza[i][11]-riqueza[zz][10]
             # riqueza[zz][11]=riqueza[zz][11]+riqueza[zz][10]#   nueva riqueza
              riqueza[zz][8]=riqueza[zz][10]#gainvest
              #print(riqueza[i][11])
              #i=len(riqueza)
              #bool=False
              break
        if riqueza[zz][12]>2:
          riqueza[zz][12]=riqueza[zz][12]-1
          #print()
      #print(riqueza[zz],t, zz)
      for x in  riqueza[zz][6]:
        #print(x,riqueza[pp][12],t)
        riqueza[zz][9]=riqueza[x][8]+riqueza[zz][9]#painvest
      if t>0:
        #print(riqueza)
        riqueza[zz][0]=riqueza[zz][11]+riqueza[zz][8]-riqueza[zz][9]-riqueza[zz][7]
      if t==steps-1:
        aux.append(riqueza[zz][11])
        aux2.append(riqueza[zz][12])
  #print(riqueza)
  #for i in range(len(riqueza)):
    #print(riqueza[i])
    #aux.append(riqueza[i][11])
  aux.sort()
  aux2.sort()
  #print(aux,aux2)
  n, bins, patches=plt.hist(aux,bins=100)#,density=True)
  #plt.title("Densidad de probabilidad")
  plt.title("Distribución de dinero ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  #plt.ylabel("Probabilidad", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.show()
def fun(x,b):
  return b*np.exp(-x/b)
  #res, cov=curve_fit(fun,bins, n)
  #print(res)
if __name__ == "__main__":
    code()

#from traitlets.traitlets import parse_notifier_name
import pandas as pd
from scipy.optimize import curve_fit
import numpy as np
import random
import matplotlib.pyplot as plt

def code():
  recurso=1.0
  sciencia=1.0
  steps=100
  energy=5000.0
  #y = np.arange(501, dtype=float)
  #aux=np.zeros_like(y)
  aux=[]#np.zeros(501)
  T=1/2
  a=10001
  #0.ahorro  1.tipor  2.production  3workincome  4 investincome 5income  6 empleados 7consumo  8ganainvest  9payinvest  10salario 11wealth 12class
  v=[energy, 0, 0.0,0.0,0.0, 0.0, [],0.0, 0.0,0.0,0.0, 5000.0, 1]#np.array(
  riqueza=[v]*a
  productividad=[0.0]*a
  #print(riqueza)
  #productividad=np.zeros(5001)#np.zeros_like(y)
  e=[2500,4500, 100000, 400000]
  for ll in range(a):#len(productividad)
      productividad[ll]=np.random.normal(loc=25000.0, scale=15000.0)
      while  productividad[ll]< 0.0:
        productividad[ll]=np.random.normal(loc=25000.0, scale=15000.0)
      riqueza[ll][2]=productividad[ll]*sciencia*recurso#production
  productividadd=productividad
  productividadd.sort()
  dinero40=[]
  dinero80=[]
  for t in range(steps):
    rand=random.uniform(0.0,100.0)
    if rand>=70:
      for zzz in range(a):
        riqueza[ll][2]=np.random.normal(loc=25000.0, scale=15000.0)*sciencia*recurso#production
      e=[4000,9000,109000,300000]
    elif rand<=10:
      e=[4000,15000,140000,200000]
      for zzz in range(a):
        riqueza[ll][2]=np.random.normal(loc=20000.0, scale=10000.0)*sciencia*recurso#production
    for zz in range(a):
      i=0
      riqueza[zz][2]=productividad[zz]*sciencia*recurso#production
      if riqueza[zz][1]==0:
        riqueza[zz][3]=riqueza[zz][2]#workincomeeeee
      elif riqueza[zz][1]==1:
        riqueza[zz][3]=riqueza[zz][10]#pago de salario
      if  len(riqueza[zz][6])!=0:  #riqueza[zz][1]==0.0 and
        for kk in riqueza[zz][6]:
          riqueza[zz][4]=riqueza[kk][2]-riqueza[kk][10]+riqueza[zz][4]#investincome
      riqueza[zz][5]=riqueza[zz][4]+riqueza[zz][3]#INCOME TOTAl
      riqueza[zz][11]=riqueza[zz][5]+riqueza[zz][0]*T #wealth
      #class diferentiation###################
      if e[0]>=riqueza[zz][11]:
        riqueza[zz][12]=1
      if t>0 and riqueza[zz][11]>=e[0] and e[1]>=riqueza[zz][11]:
        riqueza[zz][12]=2
      elif riqueza[zz][11]>=e[1] and e[2]>=riqueza[zz][11]:
          riqueza[zz][12]=3
      elif riqueza[zz][11]>=e[2]:
          riqueza[zz][12]=4
      if riqueza[zz][12]==1:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 500.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0],riqueza[zz][11]/4)
      elif riqueza[zz][12]==2:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 1500.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/4)
      elif riqueza[zz][12]==3:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 40000.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/4)
      if riqueza[zz][12]==4:
        riqueza[zz][7]=e[riqueza[zz][12]-1]+np.random.normal(0.0, 100000.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/4)
      riqueza[zz][11]=riqueza[zz][11]-riqueza[zz][7]+riqueza[zz][5]
      auxriqueza=riqueza
      if riqueza[zz][11]<=e[riqueza[zz][12]-1]:
        if riqueza[zz][12]<3:
          while i< len(productividad)-1:
            riqueza[i]=auxriqueza[i]
            i=i+1
            if auxriqueza[i][12]>2 :
              riqueza[zz][1]=1
              productividad[zz]=(productividad[zz]+productividad[i])*0.5
              riqueza[i][6].append(zz)
              riqueza[zz][10]=e[0]#salario#   nueva riqueza
              riqueza[zz][8]=riqueza[zz][10]#gainvest
              break
        if riqueza[zz][12]>2:
          riqueza[zz][12]=riqueza[zz][12]-1
      for x in  riqueza[zz][6]:
        riqueza[zz][9]=riqueza[x][8]+riqueza[zz][9]#painvest
      if t>0:
        riqueza[zz][0]=riqueza[zz][11]+riqueza[zz][8]-riqueza[zz][9]-riqueza[zz][7]
      if t==steps-1:
        aux.append(riqueza[zz][11])
      if t==40:
        dinero40.append(riqueza[zz][11])
      if t==80:
        dinero80.append(riqueza[zz][11])
  aux.sort()
  dinero40.sort()
  dinero80.sort()
  #print(aux)
  n40, bins40, patches=plt.hist(dinero40,bins=100)
  plt.title("Distribución de dinero en paso 40 ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.xlim(0,300000)
  #plt.yscale("log")
  plt.show()
  n80, bins80, patches=plt.hist(dinero80,bins=100)
  plt.title("Distribución de dinero en paso 80 ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.xlim(0,300000)
  #plt.yscale("log")
  plt.show()
  aux=np.abs(aux)
  n, bins, patches=plt.hist(aux,bins=100)
  plt.title("Distribución de dinero ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.xlim(0,300000)
  #plt.yscale("log")
  plt.show()
  #productividad.sort()
  nn, binss, patches=plt.hist(productividadd,bins=100)
  plt.title("Distribución de productividad ", size = 16)
  plt.xlabel("Productividad (ua)", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.xlim(0,100000)
  plt.show()
  n=np.append(n,1)
  fraccion=[0.0]*a
  fraccionacum=[0.0]*a
  b=1.0/a
  aux3=[b]*a
  entro=0.0
  suma=0.0
  cont=0
  for x in range(len(bins)-1):
    if n[x]==0:
      n[x]=1
      cont=cont+1
    entro=entro-(n[x]/a)*np.log(n[x]/a)
  qq=0
  suma=0.0
  aux=np.abs(aux)
  aa=np.sum(aux)
  prom=aa/a
  for  kk in range(a):
      fraccion[kk]=(aux[kk]/aa)
      if(kk==0):
        fraccionacum[kk]= fraccion[kk]

      aux3[kk]=(kk+1)*b
      while(qq<kk):
        fraccionacum[kk]=fraccionacum[kk]+fraccion[qq]
        qq=qq+1
      qq=0
  for kk in range(a-1):
    suma=(fraccionacum[kk]+fraccionacum[kk+1])*(aux3[kk+1]-aux3[kk])+suma

  gini=1.0-suma;
  #  //calculo gini////////////////////////////////////////////////
#//calculo theil//////////////////////////////////////////////////
  suma2=0.0
  for kk in range(a):
    aux[kk]=aux[kk]/prom
    suma2=(aux[kk])*(np.log(aux[kk]))+ suma2

  theil=suma2/a
  theilnormalizado=theil/np.log(a)
  print( gini , theil, theilnormalizado,entro)
  for x in range(len(bins)-1):
    print(n[x],bins[x])
   #///////////////////////////////////////////////////////////////////
if __name__ == "__main__":
    code()
def fun(x,b):
  return np.exp(-x/b)



import pandas as pd
from matplotlib.colors import LogNorm
from scipy.optimize import curve_fit
import numpy as np
import random
import matplotlib.pyplot as plt

def code():
  recurso=1.0
  sciencia=1.0
  simu=10
  steps=10
  energy=5000.0
  aux=[]
  auxriqueza=[1]*50001
  aux2=[]
  T=1/2
  #0.ahorro  1.tipor  2.production  3workincome  4 investincome 5income  6 empleados 7consumo  8ganainvest  9payinvest  10salario 11wealth 12class
  v=[energy, 0, 0.0,0.0,0.0, 0.0, [],0.0, 0.0,0.0,0.0, 5000.0]
  riqueza=[v]*50001
  productividad=[0.0]*50001
  e=[2500,7500, 200000, 1000000]
  for ll in range(len(productividad)):
      productividad[ll]=np.random.normal(loc=5000.0, scale=5000.0)
      while  productividad[ll]< 0.0:
        productividad[ll]=np.random.normal(loc=5000.0, scale=5000.0)
      riqueza[ll][2]=productividad[ll]*sciencia*recurso#production
  for t in range(steps):
    for zz in range(len(productividad)):
      riqueza[zz][2]=productividad[zz]*sciencia*recurso#production
      if riqueza[zz][1]==0:
        riqueza[zz][3]=riqueza[zz][2]#workincomeeeee
      elif riqueza[zz][1]==1:
        riqueza[zz][3]=riqueza[zz][10]#pago de salario
      if  len(riqueza[zz][6])!=0:  #riqueza[zz][1]==0.0 and
        for kk in riqueza[zz][6]:
          riqueza[zz][4]=riqueza[kk][2]-riqueza[kk][10]+riqueza[zz][4]#investincome
      riqueza[zz][5]=riqueza[zz][4]+riqueza[zz][3]#INCOME TOTAl
      riqueza[zz][11]=riqueza[zz][5]+riqueza[zz][0]*T #wealth
      #class diferentiation###################
      if e[0]>=riqueza[zz][11]:
        auxriqueza[zz]=1
      if t>0 and riqueza[zz][11]>=e[0] and e[1]>=riqueza[zz][11]:
        auxriqueza[zz]=2
      elif riqueza[zz][11]>=e[1] and e[2]>=riqueza[zz][11]:
          auxriqueza[zz]=3
      elif riqueza[zz][11]>=e[2]:
          auxriqueza[zz]=4

      if auxriqueza[zz]==1:
        riqueza[zz][7]=e[auxriqueza[zz]-1]+np.random.normal(0.0, 500.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0],riqueza[zz][11]/2)
      elif auxriqueza[zz]==2:
        riqueza[zz][7]=e[auxriqueza[zz]-1]+np.random.normal(0.0, 1500.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/2)
      elif auxriqueza[zz]==3:
        riqueza[zz][7]=e[auxriqueza[zz]-1]+np.random.normal(0.0, 40000.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/2)
      if auxriqueza[zz]==4:
        riqueza[zz][7]=e[auxriqueza[zz]-1]+np.random.normal(0.0, 200000.0)
        if  riqueza[zz][11]<riqueza[zz][7] or riqueza[zz][7]<=e[0]:
          riqueza[zz][7]=random.uniform(e[0], riqueza[zz][11]/2)
      riqueza[zz][11]=riqueza[zz][11]-riqueza[zz][7]#+riqueza[zz][5]

      if t>0:
        if riqueza[zz][11]<=e[auxriqueza[zz]-1]:
          if auxriqueza[zz]<3:
            print("empleooo000000000000000000000oo")
            a=1
            while a==1:
              i=random.randint(0,50000)
              if auxriqueza[i]>2:# and riqueza[zz][2]-2500>0:
                a=2
            riqueza[zz][1]=1
            productividad[zz]=(productividad[zz]+productividad[i])*0.5
            riqueza[i][6].append(zz)
            riqueza[zz][10]=e[0]#salario
            riqueza[zz][8]=riqueza[zz][10]#gainvest
            riqueza[i][11]=riqueza[i][11]-riqueza[zz][10]
            riqueza[zz][11]=riqueza[zz][11]+riqueza[zz][10]#   nueva riqueza

          if auxriqueza[zz]>2:
            auxriqueza[zz]=auxriqueza[zz]-1
      for x in  riqueza[zz][6]:
        riqueza[zz][9]=riqueza[x][8]+riqueza[zz][9]#painvest
      if t>0:
        riqueza[zz][0]=riqueza[zz][11]+riqueza[zz][8]-riqueza[zz][9]-riqueza[zz][7]
      if t==steps-1:
        aux.append(riqueza[zz][11])
  aux.sort()
  n, bins, patches=plt.hist(aux,bins=100)
  plt.title("Distribución de dinero ", size = 16)
  plt.xlabel("Dinero (ua)", size = 16)
  plt.ylabel("número de agentes", size = 16)
  plt.show()
def fun(x,b):
  return b*np.exp(-x/b)
  #res, cov=curve_fit(fun,bins, n)
  #print(res)
if __name__ == "__main__":
    code()